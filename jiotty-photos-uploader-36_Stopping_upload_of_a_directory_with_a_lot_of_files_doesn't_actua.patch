Index: .idea/runConfigurations/LocalUiLauncher_zh_HANS.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/runConfigurations/LocalUiLauncher_zh_HANS.xml	(revision 8939a5bfe72c9ac8e020ee5bbd4996ab6fb10d0a)
+++ .idea/runConfigurations/LocalUiLauncher_zh_HANS.xml	(revision 8939a5bfe72c9ac8e020ee5bbd4996ab6fb10d0a)
@@ -0,0 +1,10 @@
+<component name="ProjectRunConfigurationManager">
+  <configuration default="false" name="LocalUiLauncher zh_HANS" type="Application" factoryName="Application">
+    <option name="MAIN_CLASS_NAME" value="net.yudichev.googlephotosupload.core.LocalUiLauncher" />
+    <module name="Jiotty_Photos_Uploader.test" />
+    <option name="VM_PARAMETERS" value="-Duser.language=zh -Duser.country=HANS" />
+    <method v="2">
+      <option name="Make" enabled="true" />
+    </method>
+  </configuration>
+</component>
\ No newline at end of file
Index: src/main/java/net/yudichev/googlephotosupload/core/BackpressuredExecutorServiceProvider.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/yudichev/googlephotosupload/core/BackpressuredExecutorServiceProvider.java	(revision 59edac3da563cdd5395b79f1fb8ad6e3bb231ddb)
+++ src/main/java/net/yudichev/googlephotosupload/core/BackpressuredExecutorServiceProvider.java	(revision 8939a5bfe72c9ac8e020ee5bbd4996ab6fb10d0a)
@@ -9,14 +9,14 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
 
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.util.concurrent.MoreExecutors.shutdownAndAwaitTermination;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
 
 final class BackpressuredExecutorServiceProvider extends BaseLifecycleComponent implements Provider<ExecutorService> {
     private static final Logger logger = LoggerFactory.getLogger(BackpressuredExecutorServiceProvider.class);
-    private final int threadCount = Runtime.getRuntime().availableProcessors() * 2;
     private ThreadPoolExecutor executor;
 
     @Override
@@ -31,19 +31,20 @@
 
     @Override
     protected void doStop() {
-        if (!shutdownAndAwaitTermination(executor, 3, TimeUnit.SECONDS)) {
-            logger.warn("Failed to shutdown upload thread pool in 3 seconds");
+        if (!shutdownAndAwaitTermination(executor, 30, SECONDS)) {
+            logger.warn("Failed to shutdown upload thread pool in 3 seconds!");
         }
+        //noinspection AssignmentToNull
         executor = null;
     }
 
     @Override
     protected void doStart() {
         executor = new ThreadPoolExecutor(
-                threadCount,
-                threadCount,
-                0L, TimeUnit.MILLISECONDS,
-                new LinkedBlockingQueue<>(threadCount * 2),
+                1,
+                1,
+                0L, MILLISECONDS,
+                new LinkedBlockingQueue<>(2),
                 new ThreadFactoryBuilder()
                         .setNameFormat("upload-pool-%s")
                         .setDaemon(true)
Index: src/main/java/net/yudichev/googlephotosupload/core/GooglePhotosUploaderImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/yudichev/googlephotosupload/core/GooglePhotosUploaderImpl.java	(revision 59edac3da563cdd5395b79f1fb8ad6e3bb231ddb)
+++ src/main/java/net/yudichev/googlephotosupload/core/GooglePhotosUploaderImpl.java	(revision 8939a5bfe72c9ac8e020ee5bbd4996ab6fb10d0a)
@@ -24,8 +24,6 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
 import java.util.stream.Stream;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -42,7 +40,6 @@
 import static net.yudichev.jiotty.common.lang.CompletableFutures.toFutureOfList;
 import static net.yudichev.jiotty.common.lang.CompletableFutures.toFutureOfListChaining;
 import static net.yudichev.jiotty.common.lang.HumanReadableExceptionMessage.humanReadableMessage;
-import static net.yudichev.jiotty.common.lang.Locks.inLock;
 import static net.yudichev.jiotty.common.lang.ResultOrFailure.failure;
 import static net.yudichev.jiotty.common.lang.ResultOrFailure.success;
 
@@ -61,7 +58,9 @@
     private final Provider<ExecutorService> executorServiceProvider;
     private final BackingOffRemoteApiExceptionHandler backOffHandler;
     private final FatalUserCorrectableRemoteApiExceptionHandler fatalUserCorrectableHandler;
-    private final Lock stateLock = new ReentrantLock();
+
+    // memory barrier for access to non-finals (as we must survive a restart), but should NOT be used to guard internal state of any other objects
+    private volatile boolean memoryBarrier = true;
 
     private StateSaver stateSaver;
     private ExecutorService executorService;
@@ -93,7 +92,7 @@
     public CompletableFuture<Void> uploadDirectory(Path albumDirectoryPath, Optional<GooglePhotosAlbum> googlePhotosAlbum, ProgressStatus fileProgressStatus) {
         checkStarted();
 
-        return supplyAsync(() -> filesystemManager.listFiles(albumDirectoryPath))
+        return supplyAsync(() -> filesystemManager.listFiles(albumDirectoryPath), executorService)
                 .thenCompose(paths -> paths.stream()
                         .map(path -> createMediaData(path)
                                 .thenApply(itemState -> {
@@ -111,37 +110,36 @@
 
     @Override
     public void doNotResume() {
-        inLock(stateLock, () -> {
-            logger.info("Requested not to resume, forgetting {} previously uploaded item(s)", uploadedItemStateByPath.size());
-            uploadState = UploadState.builder().build();
-            uploadStateManager.save(uploadState);
-            uploadedItemStateByPath.clear();
-        });
+        checkStarted();
+        checkState(memoryBarrier);
+        logger.info("Requested not to resume, forgetting {} previously uploaded item(s)", uploadedItemStateByPath.size());
+        uploadState = UploadState.builder().build();
+        uploadStateManager.save(uploadState);
+        uploadedItemStateByPath.clear();
+        memoryBarrier = true;
     }
 
     @Override
     public int canResume() {
-        return (int) uploadStateManager.get().uploadedMediaItemIdByAbsolutePath().values().stream()
-                .filter(itemState -> itemState.mediaId().isPresent())
-                .count();
+        return (int) uploadStateManager.get().uploadedMediaItemIdByAbsolutePath().size();
     }
 
     @Override
     protected void doStart() {
-        inLock(stateLock, () -> {
-            executorService = executorServiceProvider.get();
-            stateSaver = stateSaverFactory.create("uploaded-items", this::saveState);
-            uploadState = uploadStateManager.get();
-            uploadedItemStateByPath = uploadState.uploadedMediaItemIdByAbsolutePath().entrySet().stream()
-                    .collect(toConcurrentMap(
-                            entry -> Paths.get(entry.getKey()),
-                            entry -> completedFuture(entry.getValue())));
-        });
+        executorService = executorServiceProvider.get();
+        stateSaver = stateSaverFactory.create("uploaded-items", this::saveState);
+        uploadState = uploadStateManager.get();
+        uploadedItemStateByPath = uploadState.uploadedMediaItemIdByAbsolutePath().entrySet().stream()
+                .collect(toConcurrentMap(
+                        entry -> Paths.get(entry.getKey()),
+                        entry -> completedFuture(entry.getValue())));
+        memoryBarrier = true;
     }
 
     @Override
     protected void doStop() {
-        inLock(stateLock, () -> stateSaver.close());
+        checkState(memoryBarrier);
+        stateSaver.close();
     }
 
     /**
@@ -150,6 +148,7 @@
      */
     private CompletableFuture<List<PathMediaItemOrError>> createMediaItems(ProgressStatus fileProgressStatus,
                                                                            List<PathState> createMediaDataResults) {
+        checkState(memoryBarrier);
         List<PathState> pendingPathStates = createMediaDataResults.stream()
                 .filter(pathState -> {
                     var itemStateOptional = pathState.state().toSuccess();
@@ -200,7 +199,8 @@
 
     private CompletableFuture<ResultOrFailure<ItemState>> createMediaData(Path file) {
         checkStarted();
-        return inLock(stateLock, () -> uploadedItemStateByPath.compute(file,
+        checkState(memoryBarrier);
+        return uploadedItemStateByPath.compute(file,
                 (theFile, currentFuture) -> {
                     if (currentFuture == null || currentFuture.isCompletedExceptionally()) {
                         logger.info("Scheduling upload of {}", file);
@@ -230,6 +230,7 @@
                     return currentFuture;
                 })
                 .thenApply(itemState -> {
+                    checkState(memoryBarrier);
                     stateSaver.save();
                     backOffHandler.reset();
                     return success(itemState);
@@ -244,7 +245,7 @@
                     } else {
                         throw new RuntimeException(exception);
                     }
-                }));
+                });
     }
 
     private CompletionStage<Void> addToAlbum(Optional<GooglePhotosAlbum> googlePhotosAlbum,
@@ -267,9 +268,12 @@
                             .distinct()
                             .collect(toImmutableList());
                     return cloudOperationHelper.withBackOffAndRetry("add items to album",
-                            () -> partition(mediaItemsToAddToAlbum, GOOGLE_PHOTOS_API_BATCH_SIZE).stream()
-                                    .collect(toFutureOfListChaining(mediaItems -> album.addMediaItems(mediaItems, executorService)))
-                                    .<Void>thenApply(ignored -> null),
+                            () -> {
+                                checkState(memoryBarrier);
+                                return partition(mediaItemsToAddToAlbum, GOOGLE_PHOTOS_API_BATCH_SIZE).stream()
+                                        .collect(toFutureOfListChaining(mediaItems -> album.addMediaItems(mediaItems, executorService)))
+                                        .<Void>thenApply(ignored -> null);
+                            },
                             fileProgressStatus::onBackoffDelay)
                             .exceptionallyCompose(exception -> {
                                 var operationName = "adding items to album " + album.getTitle();
@@ -306,6 +310,7 @@
     }
 
     private void saveState() {
+        checkState(memoryBarrier);
         var newUploadState = UploadState.of(
                 uploadedItemStateByPath.entrySet().stream()
                         .filter(entry -> entry.getValue().isDone() && !entry.getValue().isCompletedExceptionally())
@@ -316,5 +321,6 @@
             uploadState = newUploadState;
             uploadStateManager.save(uploadState);
         }
+        memoryBarrier = true;
     }
 }
\ No newline at end of file
Index: src/main/java/net/yudichev/googlephotosupload/core/UploadStateManagerImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/yudichev/googlephotosupload/core/UploadStateManagerImpl.java	(revision 59edac3da563cdd5395b79f1fb8ad6e3bb231ddb)
+++ src/main/java/net/yudichev/googlephotosupload/core/UploadStateManagerImpl.java	(revision 8939a5bfe72c9ac8e020ee5bbd4996ab6fb10d0a)
@@ -1,19 +1,24 @@
 package net.yudichev.googlephotosupload.core;
 
 import net.yudichev.jiotty.common.varstore.VarStore;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import javax.inject.Inject;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static java.lang.System.identityHashCode;
 import static net.yudichev.jiotty.common.lang.Locks.inLock;
 
 final class UploadStateManagerImpl implements UploadStateManager {
+    private static final Logger logger = LoggerFactory.getLogger(UploadStateManagerImpl.class);
+
     private static final String VAR_STORE_KEY = "photosUploader";
     private final VarStore varStore;
     private final Lock lock = new ReentrantLock();
-    private volatile UploadState uploadState;
+    private UploadState uploadState;
 
     @Inject
     UploadStateManagerImpl(VarStore varStore) {
@@ -23,7 +28,7 @@
 
     @Override
     public UploadState get() {
-        return uploadState;
+        return inLock(lock, () -> uploadState);
     }
 
     @Override
@@ -31,6 +36,7 @@
         inLock(lock, () -> {
             this.uploadState = uploadState;
             varStore.saveValue(VAR_STORE_KEY, uploadState);
+            logger.debug("Saved state {} with {} item(s)", identityHashCode(uploadState), uploadState.uploadedMediaItemIdByAbsolutePath().size());
         });
     }
 }
Index: src/main/java/net/yudichev/googlephotosupload/ui/FolderSelectorControllerImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/yudichev/googlephotosupload/ui/FolderSelectorControllerImpl.java	(revision 59edac3da563cdd5395b79f1fb8ad6e3bb231ddb)
+++ src/main/java/net/yudichev/googlephotosupload/ui/FolderSelectorControllerImpl.java	(revision 8939a5bfe72c9ac8e020ee5bbd4996ab6fb10d0a)
@@ -1,5 +1,6 @@
 package net.yudichev.googlephotosupload.ui;
 
+import javafx.application.Platform;
 import javafx.event.ActionEvent;
 import javafx.scene.control.CheckBox;
 import javafx.scene.control.Label;
@@ -11,6 +12,7 @@
 import javafx.scene.layout.VBox;
 import javafx.stage.DirectoryChooser;
 import net.yudichev.googlephotosupload.core.Uploader;
+import net.yudichev.jiotty.common.inject.BaseLifecycleComponent;
 
 import javax.inject.Inject;
 import java.io.File;
@@ -21,7 +23,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
-public final class FolderSelectorControllerImpl implements FolderSelectorController {
+public final class FolderSelectorControllerImpl extends BaseLifecycleComponent implements FolderSelectorController {
     private final Uploader uploader;
     private final ResourceBundle resourceBundle;
     public VBox folderSelector;
@@ -29,6 +31,7 @@
     public FlowPane resumePane;
     public Label alreadyUploadedLabel;
     private BiConsumer<Path, Boolean> folderSelectionListener;
+    private volatile boolean everInitialised;
 
     @Inject
     FolderSelectorControllerImpl(Uploader uploader,
@@ -37,6 +40,25 @@
         this.resourceBundle = checkNotNull(resourceBundle);
     }
 
+    public void initialize() {
+        var numberOfUploadedItems = uploader.numberOfUploadedItems();
+        if (numberOfUploadedItems > 0) {
+            alreadyUploadedLabel.setText(String.format("(%s %s)", resourceBundle.getString("folderSelectorAlreadyUploadedLabelPrefix"), numberOfUploadedItems));
+            resumePane.setVisible(true);
+        } else {
+            resumePane.setVisible(false);
+        }
+        everInitialised = true;
+    }
+
+    @Override
+    protected void doStart() {
+        // re-initialise on restart
+        if (everInitialised) {
+            Platform.runLater(this::initialize);
+        }
+    }
+
     @SuppressWarnings("MethodMayBeStatic")
     public void folderSelectorOnDragOver(DragEvent event) {
         if (isSingleFolder(event.getDragboard())) {
@@ -81,16 +103,6 @@
         event.consume();
     }
 
-    public void initialize() {
-        var numberOfUploadedItems = uploader.numberOfUploadedItems();
-        if (numberOfUploadedItems > 0) {
-            alreadyUploadedLabel.setText(String.format("(%s %s)", resourceBundle.getString("folderSelectorAlreadyUploadedLabelPrefix"), numberOfUploadedItems));
-            resumePane.setVisible(true);
-        } else {
-            resumePane.setVisible(false);
-        }
-    }
-
     private void notifyListener(File file) {
         folderSelectionListener.accept(file.toPath(), resumeCheckbox.isSelected());
     }
Index: src/main/java/net/yudichev/googlephotosupload/ui/UiModule.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/net/yudichev/googlephotosupload/ui/UiModule.java	(revision 59edac3da563cdd5395b79f1fb8ad6e3bb231ddb)
+++ src/main/java/net/yudichev/googlephotosupload/ui/UiModule.java	(revision 8939a5bfe72c9ac8e020ee5bbd4996ab6fb10d0a)
@@ -68,8 +68,7 @@
         bind(LoginDialogControllerImpl.class).in(Singleton.class);
         bind(LoginDialogFxController.class).to(LoginDialogControllerImpl.class);
 
-        bind(FolderSelectorControllerImpl.class).in(Singleton.class);
-        bind(FolderSelectorController.class).to(FolderSelectorControllerImpl.class);
+        bind(FolderSelectorController.class).to(boundLifecycleComponent(FolderSelectorControllerImpl.class));
 
         bind(PreferencesDialogController.class).in(Singleton.class);
         bind(PreferencesSupplier.class).to(PreferencesDialogController.class);
